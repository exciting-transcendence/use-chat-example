import { useMemo, useCallback, useEffect } from 'react'

import {
  MainContainer,
  Sidebar,
  ConversationList,
  Conversation as ConversationComponent,
  Avatar,
  ChatContainer,
  ConversationHeader,
  MessageGroup as MessageGroupComponent,
  Message,
  MessageList,
  MessageInput,
  TypingIndicator,
  AvatarGroup,
} from '@chatscope/chat-ui-kit-react'

import {
  useChat,
  ChatMessage,
  MessageContentType,
  MessageDirection,
  MessageStatus,
  Participant,
} from '@chatscope/use-chat'
import { MessageContent, TextContent, User } from '@chatscope/use-chat'
import { MessageGroup } from '@chatscope/use-chat/dist/MessageGroup'

export const Chat = ({ user }: { user: User }) => {
  // Get all chat related values and methods from useChat hook
  const {
    currentMessages,
    conversations,
    activeConversation,
    setActiveConversation,
    sendMessage,
    getUser,
    currentMessage,
    setCurrentMessage,
    sendTyping,
    setCurrentUser,
  } = useChat()

  useEffect(() => {
    setCurrentUser(user)
  }, [user, setCurrentUser])

  const createPreview = (participants: Participant[]) => {
    const users = participants
      .map(p => getUser(p.id))
      .filter(u => u !== undefined) as User[]

    switch (users.length) {
      case 0:
        return [undefined, undefined]
      case 1:
        const user = users[0]
        return [<Avatar src={user.avatar} />, user.username]
      default:
        const avatar = (
          <AvatarGroup size="sm">
            {users.map(user => (
              <Avatar key={user.id} src={user.avatar} name={user.username} />
            ))}
          </AvatarGroup>
        )
        const name = users.map(u => u.username).join(', ')
        return [avatar, name]
    }
  }

  // Get current user data
  const [currentUserAvatar, currentUserName] = useMemo(() => {
    if (!activeConversation) {
      return [undefined, undefined]
    }

    const participants = activeConversation.participants
    return createPreview(participants)
  }, [activeConversation, getUser])

  const handleChange = (value: string) => {
    // Send typing indicator to the active conversation
    // You can call this method on each onChange event
    // because sendTyping method can throttle sending this event
    // So typing event will not be send to often to the server
    setCurrentMessage(value)
    if (activeConversation) {
      sendTyping({
        conversationId: activeConversation?.id,
        isTyping: true,
        userId: user.id,
        content: value, // Note! Most often you don't want to send what the user types, as this can violate his privacy!
        throttle: true,
      })
    }
  }

  const handleSend = (text: string) => {
    const message = new ChatMessage({
      id: '', // Id will be generated by storage generator, so here you can pass an empty string
      content: text as unknown as MessageContent<TextContent>,
      contentType: MessageContentType.TextHtml,
      senderId: user.id,
      direction: MessageDirection.Outgoing,
      status: MessageStatus.Sent,
    })

    if (activeConversation) {
      sendMessage({
        message,
        conversationId: activeConversation.id,
        senderId: user.id,
      })
    }
  }

  const getTypingIndicator = useCallback(() => {
    if (!activeConversation) {
      return undefined
    }

    const typingUsers = activeConversation.typingUsers
    if (typingUsers.length == 0) {
      return undefined
    }

    const typingUserId = typingUsers.items[0].userId

    // Check if typing user participates in the conversation
    if (!activeConversation.participantExists(typingUserId)) {
      return undefined
    }

    const typingUser = getUser(typingUserId)
    if (!typingUser) {
      return undefined
    }

    return <TypingIndicator content={`${typingUser.username} is typing`} />
  }, [activeConversation, getUser])

  const getMessageAvatar = (g: MessageGroup) => {
    const sender = getUser(g.senderId)
    // FIXME: didn't check if user was self but it works
    return sender ? <Avatar src={sender.avatar} /> : null
  }

  return (
    <MainContainer responsive>
      <Sidebar position="left" scrollable>
        <ConversationHeader style={{ backgroundColor: '#fff' }}>
          <Avatar src={user.avatar} />
          <ConversationHeader.Content>
            {user.username}
          </ConversationHeader.Content>
        </ConversationHeader>
        <ConversationList>
          {conversations.map(c => {
            const [avatar, name] = createPreview(c.participants)

            return (
              <ConversationComponent
                key={c.id}
                name={name}
                info={
                  c.draft
                    ? `Draft: ${c.draft
                        .replace(/<br>/g, '\n')
                        .replace(/&nbsp;/g, ' ')}`
                    : ``
                }
                active={activeConversation?.id === c.id}
                unreadCnt={c.unreadCounter}
                onClick={() => setActiveConversation(c.id)}
              >
                {avatar}
              </ConversationComponent>
            )
          })}
        </ConversationList>
      </Sidebar>

      <ChatContainer>
        {activeConversation && (
          <ConversationHeader>
            {currentUserAvatar}
            <ConversationHeader.Content userName={currentUserName} />
          </ConversationHeader>
        )}
        <MessageList typingIndicator={getTypingIndicator()}>
          {activeConversation &&
            currentMessages.map(g => (
              <MessageGroupComponent key={g.id} direction={g.direction}>
                {activeConversation.participants.length >= 2
                  ? getMessageAvatar(g)
                  : null}
                <MessageGroupComponent.Messages>
                  {g.messages.map((m: ChatMessage<MessageContentType>) => (
                    <Message
                      key={m.id}
                      model={{
                        type: 'html',
                        payload: m.content,
                        direction: m.direction,
                        position: 'normal',
                      }}
                    />
                  ))}
                </MessageGroupComponent.Messages>
              </MessageGroupComponent>
            ))}
        </MessageList>
        <MessageInput
          value={currentMessage}
          onChange={handleChange}
          onSend={handleSend}
          disabled={!activeConversation}
          attachButton={false}
          placeholder="Type here..."
        />
      </ChatContainer>
    </MainContainer>
  )
}
